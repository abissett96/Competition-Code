#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BRD,           tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           launch1,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           launch2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           launch3,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           launch4,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           strafe,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          FRD,           tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Gearbox on the launcher.
const float LAUNCH_RATIO = (86 * 86) / (36 * 12);

//Wheel speed in RPM.
const float SPEED[] = {1000, 2000};

//Constants for PID conrol of launcher
//Sample time in ms
const int dt = 50;
//Proportional Constant
float K_P;
//Integral Constant
float K_I;
//Derivative Constant
float K_D;

//Tank drive
void tankDrive(int left, int right)
{
	motor[BLD] = motor[FLD] = left;
	motor[BRD] = motor[FRD] = right;
}

void strafeDrive(int speed, int turn, int sideSpeed)
{
	motor[BLD] = motor[FLD] = speed + turn;
	motor[BRD] = motor[FRD] = speed - turn;
	motor[strafe] = sideSpeed;
}

//Intake Speed
void intakeControl(int speed)
{
	motor[intake] = speed;
}

task PIDLaunchControl()
{
	int select = 0;
	float targetSpeed = 0,
		error = 0,
		lastError = 0,
		integral = 0,
		derivative = 0,
		pid = 0;

	//All motors are controlled by the encoder.
	slaveMotor(launch2, launch1);
	slaveMotor(launch3, launch1);
	slaveMotor(launch4, launch1);

	while (true)
	{
		//Select speed setting.
		if (vexRT[Btn8D])
			select = 0;
		else if (vexRT[Btn8R])
			select = 1;

		//Set target speed for the motors.
		targetSpeed = (SPEED[select] / LAUNCH_RATIO) * vexRT[Btn6U];

		//Calculate error
		lastError = error;
		error = targetSpeed - getMotorVelocity(launch1);

		//Integrates and differentiates
		integral += error * dt;
		derivative = (error - lastError) / dt;

		//Motor speed aproaches target.
		pid = K_P * error + K_I * integral + K_D * derivative;
		motor[launch1] = (int)(pid);

		wait1Msec(dt);
	}
}

/**************************
This code causes the launch wheel velocity to oscillate

task launchControl()
{
	int targetSpeed = 0,
		motorSpeed = 0,
		select = 0;

	//All motors are controlled by the encoder.
	slaveMotor(launch2, launch1);
	slaveMotor(launch3, launch1);
	slaveMotor(launch4, launch1);

	while (true)
	{
		//Select speed setting.
		if (vexRT[Btn8D])
			select = 0;
		else if (vexRT[Btn8R])
			select = 1;

		//Set target speed for the motors.
		targetSpeed = (int)(SPEED[select] / LAUNCH_RATIO) * vexRT[Btn6U];

		//Motor speed aproaches target.
		motorSpeed += sgn(targetSpeed - getMotorVelocity(launch1));
		motor[launch1] = motorSpeed;
	}
}
**************************/



void pre_auton()
{
  bStopTasksBetweenModes = true;
}



task autonomous()
{
	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}



task usercontrol()
{
	//startTask(PIDLaunchControl);

	while (true)
	{
		motor[launch4] = motor[launch3] = motor[launch2] = motor[launch1] = 127 * vexRT[Btn6U];
		strafeDrive(vexRT[Ch3], vexRT[Ch1], vexRT[Ch4]);
		intakeControl(127 * (vexRT[Btn5U] - vexRT[Btn5D]));
	}
}
