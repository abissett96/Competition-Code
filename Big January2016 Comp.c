#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           BRD,           tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           launch1,       tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           launch2,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           launch3,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           launch4,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           strafe,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           FLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          FRD,           tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Gearbox on the launcher.
const float LAUNCH_RATIO = (84 / 36) * (84 / 12);

//Wheel speed in RPM.
const float SPEED[] = {1000, 2100};

//Offset for launch control.
const int LAUNCH_OFFSET[] = {70, 100};

//Constants for PID conrol of launcher
//Sample time in ms (20ms => 50Hz)
const int DT = 20;
//Proportional Constant
float K_P = 0.1;
//Integral Constant
float K_I = 0.01;
//Derivative Constant
float K_D = 0.05;

//Used to measure motor speed in the debugger.
float speedDebug = 0;

void tankDrive(int left, int right)
{
	motor[BLD] = motor[FLD] = left;
	motor[BRD] = motor[FRD] = right;
}

void strafeDrive(int speed, int turn, int sideSpeed)
{
	motor[BLD] = motor[FLD] = speed + turn;
	motor[BRD] = motor[FRD] = speed - turn;
	motor[strafe] = sideSpeed;
}

//Intake Speed
void intakeControl(int speed)
{
	motor[intake] = speed;
}

void launch(int s)
{
	motor[launch1] = motor[launch2] = motor[launch3] = motor[launch4] = s;
}

//PID algorithm to control the launch wheel speed.
task PIDLaunchControl()
{
	static int launchActivated = true;
	int select = 0,
		pid = 0;
	float targetSpeed = 0,
		motorSpeed = 0,
		error = 0,
		lastError = 0,
		integral = 0,
		derivative = 0;

	//All motors are controlled by the encoder on launch1.
	slaveMotor(launch2, launch1);
	slaveMotor(launch3, launch1);
	slaveMotor(launch4, launch1);

	//Resets timer which controls refresh rate
	clearTimer(T1);

	while (true)
	{
		if (launchActivated && time1[T1] > DT)
		{
			//Select speed setting.
			if (vexRT[Btn8D])
				select = 0;
			else if (vexRT[Btn8R])
				select = 1;

			//Set target speed for the motors.
			targetSpeed = (SPEED[select] / LAUNCH_RATIO) * vexRT[Btn6U];
			//Reads actual motor speed.
			motorSpeed = getMotorVelocity(launch1);

			//Calculates error
			lastError = error;
			error = targetSpeed - motorSpeed;

			//Integrates and differentiates
			integral +=  error * DT;
			derivative = (error - lastError) / DT;

			//Calculated new motor speed.
			pid = (int)(K_P * error + K_I * integral + K_D * derivative) + LAUNCH_OFFSET[select] * vexRT[Btn6U];

			if (pid > 127)
				pid = 127;
			else if (pid < 0)
				pid = 0;

			motor[launch1] = pid;

			clearTimer(T1);
		}
	}
}

task PLaunchControl()
{
	int select = 0,
		control = 0;
	float error = 0,
		motorSpeed = 0,
		targetSpeed = 0;

	//All motors are controlled by the encoder on launch1.
	slaveMotor(launch2, launch1);
	slaveMotor(launch3, launch1);
	slaveMotor(launch4, launch1);

	while (true)
	{
		if (vexRT[Btn8D])
			select = 0;
		else if (vexRT[Btn8R])
			select = 1;

		//Set target speed for the motors.
		targetSpeed = (SPEED[select] / LAUNCH_RATIO) * vexRT[Btn6U];
		//Reads actual motor speed.
		motorSpeed = getMotorVelocity(launch1);

		//Calculates error
		error = targetSpeed - motorSpeed;

		//Calculates new motor speed.
		control = (int)(K_P * error) + LAUNCH_OFFSET[select] * vexRT[Btn6U];

		if (control > 127)
			control = 127;
		else if (control < 0)
			control = 0;

		motor[launch1] = control;

		wait1Msec(DT);
	}
}

task ManualLaunchControl()
{
	bool btnPressed = false;
	int launchSpeed = 85;

	//All motors are controlled by the encoder on launch1.
	slaveMotor(launch2, launch1);
	slaveMotor(launch3, launch1);
	slaveMotor(launch4, launch1);

	while (true)
	{
		//Checks for button presses.
		if (btnPressed && !vexRT[Btn8R] && !vexRT[Btn8D])
			btnPressed = false;
		else if (!btnPressed && vexRT[Btn8R])
		{
			launchSpeed += 5;
			btnPressed = true;
		}
		else if (!btnPressed && vexRT[Btn8D])
		{
			launchSpeed -= 5;
			btnPressed = true;
		}

		//Corrects invalid values for motor speeds.
		if (launchSpeed > 127)
			launchSpeed = 127;
		else if (launchSpeed < 0)
			launchSpeed = 0;

		//Default settings for motor speeds.
		if (vexRT[Btn7L])
			launchSpeed = 85;
		else if (vexRT[Btn7D])
			launchSpeed = 70;

		motor[launch1] = launchSpeed * vexRT[Btn6U];
	}
}

void pre_auton()
{
  bStopTasksBetweenModes = true;

  //All motors are controlled by the encoder on launch1.
	slaveMotor(launch2, launch1);
	slaveMotor(launch3, launch1);
	slaveMotor(launch4, launch1);
}



task autonomous()
{
	motor[launch1] = 85;	//Activates launcher.

	wait1Msec(5000);			//Waits for speed up.
	intakeControl(127);		//Activates conveyor belt.
	wait1Msec(500);				//Waits for balls to launch.
	intakeControl(0);			//Deactivates conveyor belt.

	wait1Msec(3000);
	intakeControl(127);
	wait1Msec(500);
	intakeControl(0);

	wait1Msec(3000);
	intakeControl(127);
	wait1Msec(500);
	intakeControl(0);

	wait1Msec(3000);
	intakeControl(127);
	wait1Msec(500);
	intakeControl(0);

	motor[launch1] = 0;		//Deactivates launcher.
}



task usercontrol()
{
	startTask(PIDLaunchControl);
	//startTask(PLaunchControl);
	//startTask(ManualLaunchControl);

	while (true)
	{
		//Reads speed of the launch wheel.
		speedDebug = getMotorVelocity(launch1) * LAUNCH_RATIO;

		strafeDrive(vexRT[Ch3] /*Speed*/ , vexRT[Ch1] /*Turn*/ ,
			(abs(vexRT[Ch4]) > 60) ? vexRT[Ch4] : 0 /*Strafe with dead zone*/ );
		intakeControl(127 * (vexRT[Btn5U] - vexRT[Btn5D]));
	}
}
